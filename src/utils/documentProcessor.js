import PDFDocument from 'pdfkit';
import { uploadToCloudinary } from '~/services/cloudinaryService';
import { ApiError } from '~/utils/apiError';
import httpStatus from 'http-status';

/**
 * Attach a stamp cover page to a document
 * @param {Object} params - Parameters for document processing
 * @param {string} params.contractId - ID of the contract
 * @param {string} params.coverPage - URL of the stamp cover page
 * @param {Buffer} [params.dscFile] - Optional DSC file for signing
 * @returns {Promise<string>} URL of the final document
 */
export const attachStampToDocument = async ({ contractId, coverPage, dscFile }) => {
	try {
		// Create a new PDF document
		const doc = new PDFDocument({
			size: 'A4',
			margin: 50
		});

		// Add stamp cover page
		doc.addContent(coverPage);

		// If DSC file is provided, add signature
		if (dscFile) {
			// Add DSC signature page
			doc.addPage();
			doc
				.fontSize(12)
				.text('Digital Signature Certificate Details:', { underline: true })
				.moveDown(0.5)
				.text(`• Certificate Serial Number: ${dscFile.serialNumber}`)
				.text(`• Valid From: ${dscFile.validFrom}`)
				.text(`• Valid To: ${dscFile.validTo}`)
				.text(`• Issuer: ${dscFile.issuer}`)
				.text(`• Subject: ${dscFile.subject}`)
				.moveDown();

			// Add signature image if available
			if (dscFile.signatureImage) {
				doc.image(dscFile.signatureImage, {
					fit: [200, 100],
					align: 'center'
				});
			}
		}

		// Add footer
		doc.fontSize(10).text('Generated by LexiFlow', { align: 'center' }).text(new Date().toLocaleString(), { align: 'center' });

		// Finalize the PDF
		doc.end();

		// Upload to Cloudinary
		const folder = `contracts/${contractId}`;
		const url = await uploadToCloudinary(doc, folder, {
			resource_type: 'raw',
			format: 'pdf'
		});

		return url;
	} catch (error) {
		throw new ApiError(httpStatus.INTERNAL_SERVER_ERROR, 'Error attaching stamp to document: ' + error.message);
	}
};

/**
 * Merge multiple PDF documents
 * @param {Array<string>} urls - Array of PDF URLs to merge
 * @param {string} outputFilename - Name of the output file
 * @returns {Promise<string>} URL of the merged document
 */
export const mergePDFs = async (urls, outputFilename) => {
	try {
		const doc = new PDFDocument({
			size: 'A4',
			margin: 50
		});

		// Add each PDF to the document
		for (const url of urls) {
			doc.addContent(url);
		}

		// Finalize the PDF
		doc.end();

		// Upload to Cloudinary
		const folder = 'merged-documents';
		const url = await uploadToCloudinary(doc, folder, {
			resource_type: 'raw',
			format: 'pdf',
			public_id: outputFilename
		});

		return url;
	} catch (error) {
		throw new ApiError(httpStatus.INTERNAL_SERVER_ERROR, 'Error merging PDFs: ' + error.message);
	}
};

/**
 * Extract text from a PDF document
 * @param {string} url - URL of the PDF document
 * @returns {Promise<string>} Extracted text
 */
export const extractTextFromPDF = async (url) => {
	try {
		// Implementation would depend on the PDF parsing library used
		// This is a placeholder for the actual implementation
		throw new Error('Not implemented');
	} catch (error) {
		throw new ApiError(httpStatus.INTERNAL_SERVER_ERROR, 'Error extracting text from PDF: ' + error.message);
	}
};
